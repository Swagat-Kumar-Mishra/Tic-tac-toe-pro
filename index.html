<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Tic Tac Toe - Aurora Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --bg-color-dark: #0c001a; --bg-color-light: #10002b; --container-bg: rgba(36, 11, 64, 0.5);
            --cell-bg: #240b40; --cell-hover-bg: #3c1268; --accent-color: #00f6ff; --accent-hover: #94faff;
            --text-color: #f0f0f0; --x-color: #ff00f0; --o-color: #f8f840; --shadow-color: rgba(0, 0, 0, 0.6);
            --winning-line-color: #ffffff; --glow-color: rgba(0, 246, 255, 0.6); --aurora-1: #3a0ca3; --aurora-2: #f72585; --aurora-3: #4cc9f0;
            --transition-speed: 0.4s;
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; background-color: var(--bg-color-dark); color: var(--text-color); font-family: 'Poppins', sans-serif; overflow: hidden; position: relative; padding: 20px; }
        #aurora-bg { position: fixed; top: -50%; left: -50%; width: 200%; height: 200%; z-index: -2; background: linear-gradient(45deg, var(--aurora-1), var(--aurora-2), var(--aurora-3), var(--bg-color-light)); background-size: 400% 400%; animation: animate-aurora 25s ease infinite; filter: blur(60px); }
        @keyframes animate-aurora { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
        #starfield-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        
        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 8vw, 3.5rem);
            margin-bottom: 20px;
            color: var(--text-color);
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px var(--accent-color), 0 0 30px var(--accent-color);
            animation: text-glow 3s ease-in-out infinite alternate;
        }
        @keyframes text-glow {
            from { text-shadow: 0 0 5px #fff, 0 0 10px var(--accent-color), 0 0 15px var(--accent-color); }
            to { text-shadow: 0 0 10px #fff, 0 0 20px var(--accent-hover), 0 0 30px var(--accent-hover); }
        }

        .container { text-align: center; background: var(--container-bg); padding: clamp(20px, 5vw, 40px); border-radius: 25px; box-shadow: 0 15px 50px var(--shadow-color); backdrop-filter: blur(15px); position: relative; width: 95vw; max-width: 500px; border: 2px solid rgba(255, 255, 255, 0.1); }
        .scoreboard { display: flex; justify-content: space-around; align-items: center; margin-bottom: clamp(15px, 4vw, 20px); font-size: clamp(0.9rem, 3vw, 1.1rem); font-weight: 600; }
        .score { padding: clamp(6px, 2vw, 10px) clamp(10px, 3vw, 18px); border-radius: 50px; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); border: 2px solid transparent; background: rgba(0,0,0,0.2); display: flex; align-items: center; gap: 8px; }
        .score .avatar { width: 30px; height: 30px; border-radius: 50%; background-color: var(--cell-bg); border: 2px solid transparent; background-size: cover; background-position: center; display: flex; justify-content: center; align-items: center; font-size: 18px; }
        .score.active-turn { transform: scale(1.1); border-color: var(--accent-color); background: rgba(0, 246, 255, 0.1); animation: active-glow 2s infinite alternate; }
        .score.active-turn .avatar { border-color: var(--accent-color); }
        @keyframes active-glow { from { box-shadow: 0 0 10px -5px var(--glow-color); } to { box-shadow: 0 0 25px 2px var(--glow-color); } }

        .board-container { position: relative; }
        .board { display: grid; grid-template-columns: repeat(3, 1fr); gap: clamp(10px, 2vw, 15px); margin-bottom: clamp(15px, 4vw, 20px); position: relative; border-radius: 15px; transition: opacity 0.3s ease, transform 0.3s ease; }
        .board.disabled { opacity: 0.6; pointer-events: none; transform: scale(0.98); }
        .board.thinking { animation: thinking-glow 1.5s infinite alternate ease-in-out; }
        @keyframes thinking-glow { from { box-shadow: 0 0 10px -5px var(--o-color); } to { box-shadow: 0 0 30px 2px var(--o-color); } }

        .cell { background-color: var(--cell-bg); display: flex; justify-content: center; align-items: center; font-weight: 700; cursor: pointer; border-radius: 15px; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); user-select: none; aspect-ratio: 1 / 1; font-size: clamp(2rem, 12vw, 4.5rem); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); border: 2px solid transparent; }
        .cell:hover:not(.x):not(.o) { background-color: var(--cell-hover-bg); transform: scale(1.05); box-shadow: 0 0 15px var(--glow-color); }
        .cell .mark { transform: scale(0); animation: pop-in-marker 0.5s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .cell .mark.custom-marker { width: 70%; height: 70%; font-size: 70%; display: flex; justify-content: center; align-items: center; }
        @keyframes pop-in-marker { 0% { transform: scale(0); opacity: 0; } 70% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
        .cell.x .mark { color: var(--x-color); text-shadow: 0 0 15px var(--x-color); }
        .cell.o .mark { color: var(--o-color); text-shadow: 0 0 15px var(--o-color); }
        #status-display { min-height: 20px; font-weight: 600; color: var(--accent-color); transition: opacity 0.3s ease; letter-spacing: 0.5px; }
        #winning-line { position: absolute; background-color: var(--winning-line-color); height: clamp(5px, 1vw, 8px); border-radius: 5px; transform-origin: left; box-shadow: 0 0 20px 3px var(--winning-line-color); filter: blur(1.5px); transform: scaleX(0); transition: transform 0.5s 0.1s cubic-bezier(0.6, 0.04, 0.98, 0.335); pointer-events: none; }
        
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px); z-index: 10; opacity: 0; pointer-events: none; transition: opacity var(--transition-speed) ease-in-out; display: flex; justify-content: center; align-items: center; }
        .overlay.visible { opacity: 1; pointer-events: auto; }
        
        #modal-slider-container { width: 100%; overflow: hidden; }
        #modal-slider { display: flex; transition: transform var(--transition-speed) cubic-bezier(0.4, 0, 0.2, 1); }
        .modal-screen { flex: 0 0 100%; display: flex; justify-content: center; align-items: center; }
        
        @keyframes pop-in-modal {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .modal { 
            background: radial-gradient(circle at 100% 100%, #2e0854, transparent 50%), radial-gradient(circle at 0% 0%, #460f6d, transparent 50%), var(--bg-color-light); 
            padding: clamp(25px, 5vw, 40px); 
            border-radius: 20px; 
            box-shadow: 0 10px 40px var(--shadow-color); 
            text-align: center; 
            width: 85vw; 
            max-width: 450px; 
            border: 1px solid rgba(255,255,255,0.2);
            opacity: 0;
            transform: scale(0.95);
        }
        .modal.animate {
             animation: pop-in-modal 0.3s calc(var(--transition-speed) / 2) forwards cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .modal h2 { margin-top: 0; color: var(--accent-color); font-size: clamp(1.5rem, 5vw, 2rem); }
        .modal p { margin: 15px 0 10px; }
        .modal .coin-cost { color: var(--o-color); font-weight: 600; margin-top: -10px;}
        .modal input { padding: 10px; width: 80%; margin-bottom: 20px; border-radius: 8px; border: 1px solid var(--accent-color); background: var(--cell-bg); color: var(--text-color); font-size: 1rem; text-align: center; }
        .modal button { display: inline-flex; align-items: center; justify-content: center; gap: 10px; padding: 12px 25px; background: linear-gradient(45deg, var(--aurora-1), var(--aurora-2)); color: var(--text-color); border: none; border-radius: 10px; cursor: pointer; font-size: clamp(0.9rem, 3vw, 1rem); font-weight: 600; transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); margin: 5px; position: relative; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
        .modal button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }
        .modal button:not(:disabled):hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(247, 37, 133, 0.5); }
        .modal button i, .modal button span { position: relative; z-index: 1; }
        .modal button.secondary { background: var(--cell-hover-bg); }
        .modal button.secondary:not(:disabled):hover { box-shadow: 0 8px 25px rgba(60, 18, 104, 0.7); }

        #coin-display { position: fixed; top: 20px; right: 20px; background: rgba(248, 248, 64, 0.1); color: var(--o-color); padding: 8px 15px; border-radius: 20px; font-weight: 600; border: 1px solid var(--o-color); box-shadow: 0 0 10px rgba(248, 248, 64, 0.4); display: flex; align-items: center; gap: 8px; z-index: 5; }
        #network-status { position: fixed; bottom: 0; left: 0; width: 100%; background-color: #c83c3c; color: white; text-align: center; padding: 5px; z-index: 1000; transform: translateY(100%); transition: transform 0.3s ease-in-out; }
        #network-status.visible { transform: translateY(0); }
        .item-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; margin: 20px 0; }
        
        #shop-menu .item-grid { max-height: 250px; overflow-y: auto; padding-right: 10px; }
        #profile-menu .item-grid { max-height: 150px; overflow-y: auto; padding-right: 10px; }

        .item-card { background: var(--cell-bg); border-radius: 15px; padding: 10px; cursor: pointer; border: 2px solid transparent; transition: all 0.3s ease; position: relative; display: flex; justify-content: center; align-items: center; aspect-ratio: 1 / 1; font-size: 40px; }
        .item-card:hover { background: var(--cell-hover-bg); transform: scale(1.05); }
        .item-card.selected { border-color: var(--accent-color); box-shadow: 0 0 15px var(--glow-color); }
        .item-card.unlocked { opacity: 0.5; background: #000; cursor: default; }
        .item-card.unlocked:hover { background: #000; transform: scale(1); } /* Prevent hover effect on unlocked items */
        .item-card .price { position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); background: var(--o-color); color: #000; font-weight: bold; padding: 2px 8px; border-radius: 10px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px; }
        .item-card .price i { font-size: 0.7rem; }
        .profile-avatar-preview { width: 100px; height: 100px; border-radius: 50%; margin: 0 auto 15px; background-size: cover; border: 4px solid var(--accent-color); box-shadow: 0 0 20px var(--glow-color); display: flex; justify-content: center; align-items: center; font-size: 50px; }
        .segmented-control { display: flex; width: 100%; border: 1px solid var(--accent-color); border-radius: 10px; overflow: hidden; margin: 20px 0; }
        .segmented-control button { flex: 1; padding: 10px; background: transparent; border: none; color: var(--text-color); cursor: pointer; transition: background 0.3s ease; font-weight: 600; }
        .segmented-control button.active { background: var(--accent-color); color: var(--bg-color-dark); }
    </style>
</head>
<body>
    <h1 class="title">Stellar Tic-Tac-Toe</h1>
    
    <div id="aurora-bg"></div>
    <canvas id="starfield-canvas"></canvas>

    <div id="network-status"><i class="fas fa-wifi"></i> You are offline. Online features are disabled.</div>
    <div id="coin-display"><i class="fa-solid fa-coins"></i> <span id="coin-count">50</span></div>

    <div class="container">
        <!-- Main Game UI -->
        <div class="scoreboard">
            <div class="score" id="playerX-score">
                <div class="avatar" id="playerX-avatar"></div>
                <span id="playerX-name">Player X</span>: <span id="playerX-score-value">0</span>
            </div>
            <div class="score" id="draws-score">Draws: 0</div>
            <div class="score" id="playerO-score">
                <div class="avatar" id="playerO-avatar"></div>
                <span id="playerO-name">Player O</span>: <span id="playerO-score-value">0</span>
            </div>
        </div>
        <div class="board-container">
            <div class="board">
                <div class="cell" data-index="0"></div><div class="cell" data-index="1"></div><div class="cell" data-index="2"></div>
                <div class="cell" data-index="3"></div><div class="cell" data-index="4"></div><div class="cell" data-index="5"></div>
                <div class="cell" data-index="6"></div><div class="cell" data-index="7"></div><div class="cell" data-index="8"></div>
            </div>
            <div id="winning-line"></div>
        </div>
        <p id="status-display"></p>
    </div>

    <!-- Modal Host moved here, outside of .container -->
    <div id="modal-host" class="overlay">
        <div id="modal-slider-container">
            <div id="modal-slider">

                <div id="game-menu" class="modal-screen">
                     <div class="modal">
                        <h2>Game Setup</h2>
                        <button data-action="show-profile"><i class="fas fa-user-astronaut"></i> <span>Profile</span></button>
                        <button data-action="show-shop"><i class="fas fa-store"></i> <span>Shop</span></button>
                        <button data-action="show-ai-menu"><i class="fas fa-robot"></i> <span>vs. AI</span></button>
                        <button data-action="show-online-menu" id="online-multiplayer-btn" disabled><i class="fas fa-globe"></i> <span>Online Multiplayer</span></button>
                    </div>
                </div>

                <div id="profile-menu" class="modal-screen">
                    <div class="modal">
                        <h2>Your Profile</h2>
                        <div id="profile-avatar-preview"></div>
                        <input type="text" id="username-input" placeholder="Enter Your Name" maxlength="12">
                        <p>Choose Your Avatar</p>
                        <div id="avatar-selection-grid" class="item-grid"></div>
                        <p>Choose Your Marker</p>
                        <div id="marker-selection-grid" class="item-grid"></div>
                        <button data-action="save-profile"><i class="fas fa-save"></i> <span>Save & Close</span></button>
                    </div>
                </div>

                <div id="shop-menu" class="modal-screen">
                    <div class="modal">
                        <h2>Stellar Shop</h2>
                        <p>Spend your coins on new items!</p>
                        <div class="segmented-control" id="shop-category-selector">
                            <button data-category="avatars" class="active">Avatars</button>
                            <button data-category="markers">Markers</button>
                        </div>
                        <div id="avatar-shop-grid" class="item-grid"></div>
                        <div id="marker-shop-grid" class="item-grid" style="display: none;"></div>
                        <button data-action="back-to-menu" class="secondary"><i class="fas fa-times"></i> <span>Close</span></button>
                    </div>
                </div>

                <div id="ai-menu" class="modal-screen">
                    <div class="modal">
                        <h2>Choose AI Difficulty</h2>
                        <div id="ai-difficulty-selector" class="segmented-control">
                            <button data-difficulty="easy" class="active">Easy</button>
                            <button data-difficulty="medium">Medium</button>
                            <button data-difficulty="hard">Hard</button>
                        </div>
                        <button data-action="start-ai-game"><i class="fas fa-play"></i> <span>Start Game</span></button>
                        <button data-action="back-to-menu" class="secondary"><i class="fas fa-arrow-left"></i> <span>Back</span></button>
                    </div>
                </div>

                <div id="online-menu" class="modal-screen">
                    <div class="modal">
                        <h2>Online Multiplayer</h2>
                        <p>Play a private match with a friend.</p>
                        <p class="coin-cost">Cost: 20 Coins</p>
                        <button data-action="create-online-game"><i class="fas fa-plus-circle"></i> <span>Create Game</span></button>
                        <button data-action="show-join-menu"><i class="fas fa-sign-in-alt"></i> <span>Join Game</span></button>
                        <button data-action="back-to-menu" class="secondary"><i class="fas fa-arrow-left"></i> <span>Back</span></button>
                    </div>
                </div>

                <div id="join-game-lobby" class="modal-screen">
                    <div class="modal">
                        <h2>Join Private Game</h2>
                        <p>Enter the Game ID:</p>
                        <input type="text" id="game-id-input" placeholder="Enter Game ID" autocomplete="off" style="text-transform: uppercase;">
                        <p class="coin-cost">Cost: 20 Coins</p>
                        <button data-action="join-online-game"><i class="fas fa-plug"></i> <span>Join</span></button>
                        <button data-action="show-online-menu" class="secondary"><i class="fas fa-arrow-left"></i> <span>Back</span></button>
                    </div>
                </div>
                <div id="waiting-lobby" class="modal-screen">
                    <div class="modal">
                        <h2>Waiting for Opponent...</h2>
                        <p>Share this Game ID with a friend:</p>
                        <h3 id="game-id-display" style="color: var(--accent-color); margin: 10px 0; letter-spacing: 2px;"></h3>
                        <button data-action="reset" class="secondary" style="margin-top: 20px;"><i class="fas fa-times"></i> <span>Cancel</span></button>
                    </div>
                </div>
                <div id="end-game-screen" class="modal-screen">
                    <div class="modal">
                        <h2 class="message"></h2>
                        <p id="rematch-status" style="min-height: 20px;"></p>
                        <button data-action="play-again"><i class="fas fa-redo"></i> <span>Play Again</span></button>
                        <button data-action="reset" class="secondary"><i class="fas fa-bars"></i> <span>Back to Menu</span></button>
                    </div>
                </div>
                <div id="custom-alert" class="modal-screen">
                    <div class="modal">
                        <h2 id="custom-alert-title">Notification</h2>
                        <p id="custom-alert-message" style="margin: 20px 0;"></p>
                        <button data-action="close-alert"><i class="fas fa-check"></i> <span>OK</span></button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
      import { getDatabase, ref, set, onValue, get, onDisconnect, off, update } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";

      // --- Firebase Config and Initialization ---
      // IMPORTANT: Replace the placeholder values below with your own Firebase project configuration.
      // You can get this from your Firebase project settings under "Project settings" > "General".
      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "",
  authDomain: "",
  databaseURL: "",
  projectId: "",
  storageBucket: "",
  messagingSenderId: "",
  appId: "",
  measurementId: ""
};

      // Initialize Firebase and start the game
      try {
          const app = initializeApp(firebaseConfig);
          const database = getDatabase(app);
          const auth = getAuth(app);
          
          // Pass auth instance and Firebase functions to the game logic
          window.ticTacToeGame(database, auth, { 
              ref, set, onValue, get, onDisconnect, off, update,
              onAuthStateChanged, signInAnonymously
          });
      } catch (e) {
          console.error("Firebase initialization failed. Please check your firebaseConfig.", e);
          // Notify user that online features are disabled if config is missing or invalid.
          const onlineBtn = document.getElementById('online-multiplayer-btn');
          const networkStatus = document.getElementById('network-status');
          if (onlineBtn) onlineBtn.disabled = true;
          if (networkStatus) {
              networkStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Online features disabled: Firebase config missing or invalid.';
              networkStatus.classList.add('visible');
          }
      }
    </script>
    
    <script>
    // --- Starfield Background Animation ---
    const canvas = document.getElementById('starfield-canvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const stars = [];
    const numStars = 300;
    for (let i = 0; i < numStars; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 1.5 + 0.5,
            alpha: Math.random(),
            vx: (Math.random() - 0.5) * 0.2,
            vy: (Math.random() - 0.5) * 0.2
        });
    }

    function animateStars() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        stars.forEach(star => {
            star.x += star.vx;
            star.y += star.vy;
            if (star.x < 0 || star.x > canvas.width) star.vx *= -1;
            if (star.y < 0 || star.y > canvas.height) star.vy *= -1;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
            ctx.fill();
        });
        requestAnimationFrame(animateStars);
    }
    animateStars();
    
    // --- Main Game Logic ---
    window.ticTacToeGame = (database, auth, fb) => {
        // --- DATA & CONSTANTS ---
        const AVATARS = {
            'avatar1':{icon:'fa-solid fa-user-astronaut',price:0},'avatar2':{icon:'fa-solid fa-user-secret',price:150},'avatar3':{icon:'fa-solid fa-user-ninja',price:250},'avatar4':{icon:'fa-solid fa-ghost',price:300},'avatar5':{icon:'fa-solid fa-dragon', price: 400},'avatar6':{icon:'fa-solid fa-skull-crossbones', price: 400},'avatar7':{icon:'fa-solid fa-hat-wizard', price: 500},'avatar8':{icon:'fa-solid fa-robot', price: 500},'avatar9':{icon:'fa-solid fa-plague-doctor', price: 600},'avatar10':{icon:'fa-solid fa-cat', price: 600},'avatar11':{icon:'fa-solid fa-wand-sparkles', price: 700},'avatar12':{icon:'fa-solid fa-meteor', price: 700},'avatar13':{icon:'fa-solid fa-hat-cowboy-side', price: 800},'avatar14':{icon:'fa-solid fa-biohazard', price: 800},'avatar15':{icon:'fa-solid fa-bug-slash', price: 900},'avatar16':{icon:'fa-solid fa-spaghetti-monster-flying', price: 900},'avatar17':{icon:'fa-solid fa-fire', price: 1000},'avatar18':{icon:'fa-solid fa-droplet', price: 1000},'avatar19':{icon:'fa-solid fa-explosion', price: 1100},'avatar20':{icon:'fa-solid fa-atom', price: 1200}
        };
        const MARKERS = {
            'default':{content:'X',type:'text',price:0,pair:'default_o'},'default_o':{content:'O',type:'text'},'rocket':{icon:'fa-solid fa-rocket',type:'icon',price:450,pair:'planet'},'planet':{icon:'fa-solid fa-earth-americas',type:'icon'},'sword':{icon:'fa-solid fa-khanda',type:'icon',price:550,pair:'shield'},'shield':{icon:'fa-solid fa-shield-halved',type:'icon'},'sun': {icon: 'fa-solid fa-sun', type: 'icon', price: 650, pair: 'moon'},'moon': {icon: 'fa-solid fa-moon', type: 'icon'},'king': {icon: 'fa-solid fa-chess-king', type: 'icon', price: 650, pair: 'bomb'},'bomb': {icon: 'fa-solid fa-bomb', type: 'icon'},'heart': {icon: 'fa-solid fa-heart', type: 'icon', price: 700, pair: 'heart-crack'},'heart-crack': {icon: 'fa-solid fa-heart-crack', type: 'icon'},'fist': {icon: 'fa-solid fa-hand-fist', type: 'icon', price: 750, pair: 'spock'},'spock': {icon: 'fa-solid fa-hand-spock', type: 'icon'},'anchor': {icon: 'fa-solid fa-anchor', type: 'icon', price: 800, pair: 'ship'},'ship': {icon: 'fa-solid fa-ship', type: 'icon'},'feather': {icon: 'fa-solid fa-feather-pointed', type: 'icon', price: 900, pair: 'book-skull'},'book-skull': {icon: 'fa-solid fa-book-skull', type: 'icon'}
        };
        const ONLINE_GAME_COST = 20;
        const WIN_PATTERNS = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ];

        // --- DOM Elements (Cached) ---
        const ui = {
            modalHost: document.getElementById('modal-host'),modalSlider: document.getElementById('modal-slider'),coinCount: document.getElementById('coin-count'),networkStatus: document.getElementById('network-status'), cells: document.querySelectorAll('.cell'), board: document.querySelector('.board'), statusDisplay: document.getElementById('status-display'), winningLine: document.getElementById('winning-line'),
            menus: { main: document.getElementById('game-menu'), profile: document.getElementById('profile-menu'), shop: document.getElementById('shop-menu'), ai: document.getElementById('ai-menu'), online: document.getElementById('online-menu'), join: document.getElementById('join-game-lobby'), waiting: document.getElementById('waiting-lobby'), end: document.getElementById('end-game-screen'), alert: document.getElementById('custom-alert'),},
            score: { playerX:document.getElementById('playerX-score'),playerO:document.getElementById('playerO-score'),draws:document.getElementById('draws-score'),playerXName:document.getElementById('playerX-name'),playerOName:document.getElementById('playerO-name'),playerXAvatar:document.getElementById('playerX-avatar'),playerOAvatar:document.getElementById('playerO-avatar'),playerXValue:document.getElementById('playerX-score-value'),playerOValue:document.getElementById('playerO-score-value')},
            buttons: { playAgain: document.querySelector('[data-action="play-again"]'), onlineMultiplayer: document.getElementById('online-multiplayer-btn'),},
            text: { gameId:document.getElementById('game-id-display'),endMessage:document.querySelector('#end-game-screen .message'),rematchStatus:document.getElementById('rematch-status'),alertTitle:document.getElementById('custom-alert-title'),alertMessage:document.getElementById('custom-alert-message'),}
        };
        const modalScreenElements = [ ui.menus.main, ui.menus.profile, ui.menus.shop, ui.menus.ai, ui.menus.online, ui.menus.join, ui.menus.waiting, ui.menus.end, ui.menus.alert ];
        const allModals = document.querySelectorAll('.modal');

        // --- Application State ---
        let appState = 'MENU'; let gameMode = 'ai'; let boardState = Array(9).fill(''); let currentPlayer = 'X'; let localScore = { X: 0, O: 0, draws: 0 }; let aiDifficulty = 'easy'; let playerRole = null; let gameId = null; let gameRef = null; let gameListener = null;
        let currentUser = null; // Holds the authenticated user object from Firebase

        // --- MANAGERS ---
        const coinManager = {
            KEY: 'stellar-tictactoe-coins',
            DEFAULT_COINS: 50,
            init() {
                let coins = localStorage.getItem(this.KEY);
                if (coins === null || isNaN(parseInt(coins, 10))) {
                    coins = this.DEFAULT_COINS;
                    localStorage.setItem(this.KEY, coins.toString());
                }
                this.updateDisplay();
            },
            get() { return parseInt(localStorage.getItem(this.KEY) || this.DEFAULT_COINS, 10); },
            set(amount) { localStorage.setItem(this.KEY, amount.toString()); this.updateDisplay(); },
            add(amount) { this.set(this.get() + amount); },
            updateDisplay() { ui.coinCount.textContent = this.get(); }
        };

        const profileManager = {
            KEY: 'stellar-tictactoe-profile',
            profile: {},
            init() {
                const storedProfile = localStorage.getItem(this.KEY);
                this.profile = storedProfile ? JSON.parse(storedProfile) : {
                    name: 'Pilot' + Math.floor(Math.random() * 1000),
                    avatar: 'avatar1',
                    markerX: 'default',
                    unlockedAvatars: ['avatar1'],
                    unlockedMarkers: ['default', 'default_o']
                };
                this.save();
            },
            get() { return JSON.parse(JSON.stringify(this.profile)); },
            save() { localStorage.setItem(this.KEY, JSON.stringify(this.profile)); },
            validateName: (name) => /^[a-zA-Z0-9]{3,12}$/.test(name),
            populateProfileMenu() {
                document.getElementById('username-input').value = this.profile.name;
                const preview = document.getElementById('profile-avatar-preview');
                preview.innerHTML = `<i class="${AVATARS[this.profile.avatar].icon}"></i>`;
                
                this._populateSelectionGrid('avatar-selection-grid', AVATARS, this.profile.unlockedAvatars, this.profile.avatar, 'avatar');
                this._populateSelectionGrid('marker-selection-grid', MARKERS, this.profile.unlockedMarkers, this.profile.markerX, 'marker');
            },
            _populateSelectionGrid(gridId, items, unlockedIds, selectedId, itemType) {
                const gridElement = document.getElementById(gridId);
                gridElement.innerHTML = '';
                unlockedIds.forEach(id => {
                    const item = items[id];
                    if (!item || id.includes('_o')) return; // Don't show 'O' markers for selection
                    
                    const card = document.createElement('div');
                    card.className = `item-card ${selectedId === id ? 'selected' : ''}`;
                    card.innerHTML = item.type === 'text' ? `<span class="mark">${item.content}</span>` : `<i class="${item.icon}"></i>`;
                    
                    card.addEventListener('click', () => {
                        if (itemType === 'avatar') this.profile.avatar = id;
                        else this.profile.markerX = id;
                        this.populateProfileMenu(); // Repopulate to update selection
                    });
                    gridElement.appendChild(card);
                });
            }
        };

        const shopManager = {
            init() { this.populateShop(); },
            populateShop() {
                const currentProfile = profileManager.get();
                this._populateGrid('avatar-shop-grid', AVATARS, currentProfile.unlockedAvatars, 'avatar');
                this._populateGrid('marker-shop-grid', MARKERS, currentProfile.unlockedMarkers, 'marker');
            },
            _populateGrid(gridId, items, unlockedIds, itemType) {
                const gridElement = document.getElementById(gridId);
                gridElement.innerHTML = '';
                Object.entries(items).forEach(([id, item]) => {
                    if (id.includes('_o') || item.price === 0) return;
                    
                    const isUnlocked = unlockedIds.includes(id);
                    const card = document.createElement('div');
                    card.className = `item-card ${isUnlocked ? 'unlocked' : ''}`;
                    card.innerHTML = item.type === 'text' ? `<span class="mark">${item.content}</span>` : `<i class="${item.icon}"></i>`;
                    
                    if (!isUnlocked) {
                        card.innerHTML += `<div class="price"><i class="fa-solid fa-coins"></i> ${item.price}</div>`;
                        card.addEventListener('click', () => this.buyItem(id, itemType, item.price));
                    }
                    gridElement.appendChild(card);
                });
            },
            buyItem(itemId, itemType, price) {
                if (coinManager.get() < price) {
                    return showAlert("Not enough coins!");
                }
                coinManager.add(-price);
                const item = (itemType === 'avatar' ? AVATARS : MARKERS)[itemId];
                
                if (itemType === 'avatar') {
                    profileManager.profile.unlockedAvatars.push(itemId);
                } else {
                    profileManager.profile.unlockedMarkers.push(itemId);
                    if (item.pair) profileManager.profile.unlockedMarkers.push(item.pair);
                }
                
                profileManager.save();
                this.populateShop();
                profileManager.populateProfileMenu();
                showAlert("Purchase successful!");
            }
        };

        // --- STATE & UI CONTROLLER ---
        function setState(newState) {
            if (appState === newState) return;
            appState = newState;
            updateUI();
        }

        function updateUI() {
            const screenMap = {
                'MENU': ui.menus.main, 'LOBBY_PROFILE': ui.menus.profile, 'LOBBY_SHOP': ui.menus.shop,
                'LOBBY_AI': ui.menus.ai, 'LOBBY_ONLINE': ui.menus.online, 'LOBBY_JOIN': ui.menus.join,
                'LOBBY_WAITING': ui.menus.waiting, 'GAME_OVER': ui.menus.end, 'ALERT': ui.menus.alert
            };

            const isModalVisible = Object.keys(screenMap).includes(appState);
            ui.modalHost.classList.toggle('visible', isModalVisible);
            allModals.forEach(modal => modal.classList.remove('animate'));

            if (isModalVisible) {
                const targetScreen = screenMap[appState];
                const screenIndex = modalScreenElements.indexOf(targetScreen);
                if (screenIndex !== -1) {
                    ui.modalSlider.style.transform = `translateX(-${screenIndex * 100}%)`;
                    const targetModal = targetScreen.querySelector('.modal');
                    if (targetModal) {
                        requestAnimationFrame(() => targetModal.classList.add('animate'));
                    }
                }
            }

            const isPlaying = appState === 'PLAYING';
            const isAnimating = appState === 'ANIMATING_WIN';
            ui.score.playerX.classList.toggle('active-turn', isPlaying && currentPlayer === 'X');
            ui.score.playerO.classList.toggle('active-turn', isPlaying && currentPlayer === 'O');
            ui.board.classList.toggle('disabled', !isPlaying || isAnimating);

            let statusText = '';
            if (isPlaying) {
                if (gameMode === 'ai') {
                    const isAITurn = currentPlayer === 'O';
                    statusText = isAITurn ? "AI is thinking..." : "Your Turn";
                    ui.board.classList.toggle('thinking', isAITurn);
                } else {
                    statusText = currentPlayer === playerRole ? "Your Turn" : "Waiting for opponent's move...";
                    ui.board.classList.remove('thinking');
                }
            } else if (appState === 'GAME_OVER' || appState === 'ANIMATING_WIN') {
                statusText = 'Game Over!';
                ui.board.classList.remove('thinking');
            }
            ui.statusDisplay.textContent = statusText;
        }

        // --- Game Flow & Event Handling ---
        function initializeAuth() {
            fb.onAuthStateChanged(auth, user => {
                if (user) {
                    currentUser = user; // Store the authenticated user
                    ui.buttons.onlineMultiplayer.disabled = !navigator.onLine;
                } else {
                    fb.signInAnonymously(auth).catch(error => {
                        console.error("Anonymous sign-in failed:", error);
                        showAlert("Could not connect to online services. Please check your connection and refresh.");
                    });
                }
            });
        }

        function initializeGameUI() {
            coinManager.init();
            profileManager.init();
            shopManager.init();
            
            // Centralized event listener for all modal buttons
            document.body.addEventListener('click', (e) => {
                const button = e.target.closest('[data-action]');
                if (!button) return;

                const action = button.dataset.action;
                const actions = {
                    'show-profile': () => { profileManager.populateProfileMenu(); setState('LOBBY_PROFILE'); },
                    'show-shop': () => { shopManager.populateShop(); setState('LOBBY_SHOP'); },
                    'show-ai-menu': () => setState('LOBBY_AI'),
                    'show-online-menu': () => setState('LOBBY_ONLINE'),
                    'save-profile': () => {
                        const newName = document.getElementById('username-input').value.trim();
                        if (profileManager.validateName(newName)) {
                            profileManager.profile.name = newName;
                            profileManager.save();
                            setState('MENU');
                        } else {
                            showAlert("Username must be 3-12 alphanumeric characters.");
                        }
                    },
                    'back-to-menu': () => setState('MENU'),
                    'start-ai-game': startAIGame,
                    'create-online-game': createOnlineGame,
                    'show-join-menu': () => setState('LOBBY_JOIN'),
                    'join-online-game': joinOnlineGame,
                    'reset': cleanupAndReset,
                    'play-again': handlePlayAgain,
                    'close-alert': () => setState(gameMode === 'online' ? 'LOBBY_ONLINE' : 'MENU'),
                };
                if (actions[action]) actions[action]();
            });

            ui.cells.forEach(cell => cell.addEventListener('click', handleCellClick));

            document.getElementById('ai-difficulty-selector').addEventListener('click', e => {
                if (e.target.tagName === 'BUTTON') {
                    aiDifficulty = e.target.dataset.difficulty;
                    document.querySelectorAll('#ai-difficulty-selector button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                }
            });

            document.getElementById('shop-category-selector').addEventListener('click', e => {
                if (e.target.tagName !== 'BUTTON') return;
                const category = e.target.dataset.category;
                document.querySelectorAll('#shop-category-selector button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                document.getElementById('avatar-shop-grid').style.display = category === 'avatars' ? 'grid' : 'none';
                document.getElementById('marker-shop-grid').style.display = category === 'markers' ? 'grid' : 'none';
            });
            
            checkNetworkStatus();
            setInterval(checkNetworkStatus, 5000);
            updateUI();
        }

        function showAlert(message, title = "Notification") {
            ui.text.alertTitle.textContent = title;
            ui.text.alertMessage.textContent = message;
            setState('ALERT');
        }

        function checkNetworkStatus() {
            const isOnline = navigator.onLine;
            ui.networkStatus.classList.toggle('visible', !isOnline);
            if(currentUser) ui.buttons.onlineMultiplayer.disabled = !isOnline;
            if (!isOnline && gameMode === 'online') {
                showAlert("Connection lost. Returning to the main menu.");
                cleanupAndReset();
            }
        }

        function cleanupAndReset() {
            if (gameMode === 'online' && gameRef) {
                fb.set(gameRef, null).catch(() => {});
            }
            if (gameListener) {
                fb.off(gameRef, 'value', gameListener);
            }
            gameId = null;
            gameRef = null;
            gameListener = null;
            playerRole = null;
            localScore = { X: 0, O: 0, draws: 0 };
            resetBoardUI();
            updateScoreboard();
            setState('MENU');
        }
        
        function startAIGame() {
            gameMode = 'ai';
            localScore = { X: 0, O: 0, draws: 0 };
            startNewRound();
        }

        function startNewRound() {
            resetBoardUI();
            currentPlayer = 'X';
            if(gameMode === 'ai') updateScoreboard();
            setState('PLAYING');
        }

        function handleCellClick(e) {
            if (appState !== 'PLAYING') return;
            
            const index = parseInt(e.currentTarget.dataset.index);
            if (boardState[index] !== '') return;

            const isMyTurn = (gameMode === 'ai' && currentPlayer === 'X') || (gameMode === 'online' && currentPlayer === playerRole);
            if (!isMyTurn) return;

            if (gameMode === 'online') {
                makeOnlineMove(index);
            } else {
                makeLocalMove(index);
            }
        }

        async function makeLocalMove(index) {
            boardState[index] = 'X';
            updateBoardUI();
            const winnerInfo = checkWinner(boardState);
            if (winnerInfo) {
                await endGame(winnerInfo);
                return;
            }

            currentPlayer = 'O';
            setState('PLAYING');
            await new Promise(resolve => setTimeout(resolve, 600)); // AI thinking delay

            if (appState !== 'PLAYING') return; // State might have changed during delay

            const aiMoveIndex = getAIMove(boardState);
            boardState[aiMoveIndex] = 'O';
            updateBoardUI();

            const aiWinnerInfo = checkWinner(boardState);
            if (aiWinnerInfo) {
                await endGame(aiWinnerInfo);
            } else {
                currentPlayer = 'X';
                setState('PLAYING');
            }
        }
        
        async function endGame(winnerInfo) {
            setState('ANIMATING_WIN');
            let message = '';
            
            if (winnerInfo.winner !== 'tie') {
                await drawWinningLine(winnerInfo.patternIndex);
            } else {
                await new Promise(res => setTimeout(res, 500)); // Short delay for draws
            }

            if (winnerInfo.winner === 'tie') {
                message = "It's a Draw!";
                if (gameMode === 'ai') localScore.draws++;
                else coinManager.add(ONLINE_GAME_COST); // Refund for draw
            } else {
                if (gameMode === 'online') {
                    const isWinner = winnerInfo.winner === playerRole;
                    message = isWinner ? 'You Win!' : 'You Lose!';
                    if (isWinner) coinManager.add(ONLINE_GAME_COST * 2); // Win prize
                } else { // AI mode
                    message = `${winnerInfo.winner} Wins!`;
                    if(winnerInfo.winner === 'X') localScore.X++; else localScore.O++;
                }
            }

            if(gameMode === 'ai') updateScoreboard();

            ui.text.endMessage.textContent = message;
            ui.buttons.playAgain.querySelector('span').textContent = gameMode === 'ai' ? "Play Again" : "Request Rematch";
            setState('GAME_OVER');
        }
        
        function handlePlayAgain() {
            if (gameMode === 'online' && gameRef) {
                ui.buttons.playAgain.disabled = true;
                ui.text.rematchStatus.textContent = "Waiting for opponent...";
                fb.update(gameRef, {
                    [`players/${playerRole}/wantsRematch`]: true,
                    status: 'REMATCH'
                });
            } else {
                startNewRound();
            }
        }

        function updateScoreboard(players) {
            const playerXProfile = (gameMode === 'online' && players) ? players.X : profileManager.get();
            const playerOProfile = (gameMode === 'online' && players) ? players.O : {name: 'AI', avatar: 'avatar8'};

            if(playerXProfile){
                ui.score.playerXName.textContent = playerXProfile.name;
                ui.score.playerXAvatar.innerHTML = `<i class="${AVATARS[playerXProfile.avatar].icon}"></i>`;
            }
            ui.score.playerXValue.textContent = localScore.X;
            
            if(playerOProfile){
                ui.score.playerOName.textContent = playerOProfile.name;
                ui.score.playerOAvatar.innerHTML = `<i class="${AVATARS[playerOProfile.avatar].icon}"></i>`;
            }
            ui.score.playerOValue.textContent = localScore.O;
            ui.score.draws.textContent = `Draws: ${localScore.draws}`;
        }
        
        function updateBoardUI(players) {
            const playerXProfile = (gameMode === 'online' && players) ? players.X : profileManager.get();
            const playerOProfile = (gameMode === 'online' && players) ? players.O : null;

            const markerXId = playerXProfile.markerX;
            const markerOId = playerOProfile ? MARKERS[playerOProfile.markerX]?.pair || 'default_o' : MARKERS[markerXId]?.pair || 'default_o';
            
            const markerXData = MARKERS[markerXId] || MARKERS['default'];
            const markerOData = MARKERS[markerOId] || MARKERS['default_o'];

            boardState.forEach((mark, index) => {
                const cell = ui.cells[index];
                if (mark && !cell.hasChildNodes()) {
                    const markerData = (mark === 'X') ? markerXData : markerOData;
                    if (!markerData) return;
                    
                    cell.innerHTML = markerData.type === 'text'
                        ? `<span class="mark">${markerData.content}</span>`
                        : `<i class="mark custom-marker ${markerData.icon}"></i>`;
                    cell.classList.add(mark.toLowerCase());
                }
            });
        }

        function resetBoardUI() {
            boardState.fill('');
            ui.winningLine.style.transform = 'scaleX(0)';
            ui.cells.forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('x', 'o');
            });
        }

        function drawWinningLine(patternIndex) {
            return new Promise(resolve => {
                if (patternIndex === null || patternIndex === undefined) { resolve(); return; }
                const pattern = WIN_PATTERNS[patternIndex];
                const startCell = ui.cells[pattern[0]];
                const endCell = ui.cells[pattern[2]];
                const boardRect = ui.board.getBoundingClientRect();
                const startRect = startCell.getBoundingClientRect();
                const endRect = endCell.getBoundingClientRect();

                const startX = startRect.left + startRect.width / 2 - boardRect.left;
                const startY = startRect.top + startRect.height / 2 - boardRect.top;
                const endX = endRect.left + endRect.width / 2 - boardRect.left;
                const endY = endRect.top + endRect.height / 2 - boardRect.top;

                const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
                const length = Math.hypot(endX - startX, endY - startY);

                ui.winningLine.style.width = `${length}px`;
                ui.winningLine.style.top = `${startY}px`;
                ui.winningLine.style.left = `${startX}px`;
                ui.winningLine.style.transform = `rotate(${angle}deg) scaleX(1)`;
                ui.winningLine.addEventListener('transitionend', resolve, { once: true });
            });
        }

        // --- ONLINE LOGIC (Now with Auth) ---
        async function createOnlineGame() {
            if (!currentUser) return showAlert("Authentication required. Please wait or refresh.");
            if (coinManager.get() < ONLINE_GAME_COST) return showAlert(`You need ${ONLINE_GAME_COST} coins to play online.`);
            
            coinManager.add(-ONLINE_GAME_COST);
            gameMode = 'online';
            playerRole = 'X';
            gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
            gameRef = fb.ref(database, 'games/' + gameId);
            ui.text.gameId.textContent = gameId;

            const profile = profileManager.get();
            profile.uid = currentUser.uid; // Attach secure user ID
            
            const newGame = {
                board: Array(9).fill(''),
                currentPlayer: 'X',
                status: 'WAITING',
                players: { X: profile },
                score: { X: 0, O: 0, draws: 0 },
            };

            try {
                await fb.set(gameRef, newGame);
                await fb.onDisconnect(gameRef).remove(); // Clean up if creator disconnects
                setState('LOBBY_WAITING');
                listenToGameUpdates();
            } catch (error) {
                console.error("Error creating game:", error);
                coinManager.add(ONLINE_GAME_COST); // Refund
                showAlert("Error creating game. Please try again.");
                cleanupAndReset();
            }
        }

        async function joinOnlineGame() {
            if (!currentUser) return showAlert("Authentication required. Please wait or refresh.");
            if (coinManager.get() < ONLINE_GAME_COST) return showAlert(`You need ${ONLINE_GAME_COST} coins to play online.`);
            
            const enteredId = document.getElementById('game-id-input').value.trim().toUpperCase();
            if (!enteredId) return showAlert('Please enter a valid Game ID.');

            gameRef = fb.ref(database, 'games/' + enteredId);
            const snapshot = await fb.get(gameRef);

            if (!snapshot.exists() || snapshot.val().players.O) {
                return showAlert('Game not found or is already full.');
            }
            
            coinManager.add(-ONLINE_GAME_COST);
            gameId = enteredId;
            gameMode = 'online';
            playerRole = 'O';

            const profile = profileManager.get();
            profile.uid = currentUser.uid; // Attach secure user ID

            const playerOPath = `games/${gameId}/players/O`;
            try {
                await fb.update(gameRef, { 'players/O': profile, status: 'PLAYING' });
                await fb.onDisconnect(fb.ref(database, playerOPath)).remove(); // Clean up if joiner disconnects
                listenToGameUpdates();
            } catch (error) {
                console.error("Error joining game:", error);
                coinManager.add(ONLINE_GAME_COST); // Refund
                showAlert("Error joining game. Please try again.");
                cleanupAndReset();
            }
        }
        
        function listenToGameUpdates() {
            if (!gameRef) return;
            gameListener = fb.onValue(gameRef, (snapshot) => {
                if (!snapshot.exists()) {
                    if (appState !== 'MENU') showAlert("The game has been terminated by the host.");
                    cleanupAndReset();
                    return;
                }
                
                const gameState = snapshot.val();
                if (gameState.players && !gameState.players[playerRole] && gameState.status !== 'WAITING') {
                    showAlert("The other player has left the game.");
                    coinManager.add(ONLINE_GAME_COST); // Refund
                    cleanupAndReset();
                    return;
                }

                boardState = gameState.board;
                currentPlayer = gameState.currentPlayer;
                localScore = gameState.score;
                updateScoreboard(gameState.players);
                updateBoardUI(gameState.players);
                
                switch (gameState.status) {
                    case 'WAITING':
                        setState('LOBBY_WAITING');
                        break;
                    case 'PLAYING':
                        if (appState !== 'PLAYING') resetBoardUI();
                        setState('PLAYING');
                        break;
                    case 'FINISHED':
                        if (appState === 'PLAYING') endGame(checkWinner(boardState, gameState.players));
                        break;
                    case 'REMATCH':
                        setState('GAME_OVER');
                        handleRematchState(gameState);
                        break;
                }
            });
        }

        function makeOnlineMove(index) {
            fb.get(gameRef).then((snapshot) => {
                if (!snapshot.exists()) return;
                
                const gameState = snapshot.val();
                if (gameState.board[index] !== '') return;

                const newBoard = [...gameState.board];
                newBoard[index] = playerRole;
                const nextPlayer = playerRole === 'X' ? 'O' : 'X';
                
                const winnerInfo = checkWinner(newBoard, gameState.players);
                let updateData = { board: newBoard, currentPlayer: nextPlayer };
                
                if (winnerInfo) {
                    const newScore = { ...gameState.score };
                    if (winnerInfo.winner === 'tie') newScore.draws++;
                    else newScore[winnerInfo.winner]++;
                    updateData = { ...updateData, status: 'FINISHED', score: newScore };
                }
                
                fb.update(gameRef, updateData);
            });
        }

        function handleRematchState(gameState) {
            ui.buttons.playAgain.disabled = false;
            ui.text.rematchStatus.textContent = "";
            const playerX = gameState.players.X;
            const playerO = gameState.players.O;

            if (playerX?.wantsRematch && playerO?.wantsRematch) {
                // Host (Player X) resets the game board for the new round
                if (playerRole === 'X') {
                    fb.update(gameRef, {
                        board: Array(9).fill(''),
                        currentPlayer: 'X',
                        status: 'PLAYING',
                        'players/X/wantsRematch': null,
                        'players/O/wantsRematch': null,
                    });
                }
            } else {
                const myRematchRequest = gameState.players[playerRole]?.wantsRematch;
                ui.buttons.playAgain.disabled = myRematchRequest;
                ui.text.rematchStatus.textContent = myRematchRequest
                    ? "Waiting for opponent..."
                    : "Opponent wants a rematch!";
            }
        }

        // --- AI & Game Logic Helpers ---
        function getAIMove(board) {
            const emptyCells = [];
            board.forEach((cell, index) => { if (cell === '') emptyCells.push(index); });

            if (aiDifficulty === 'easy' || (aiDifficulty === 'medium' && Math.random() < 0.5)) {
                return emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }
            // Hard difficulty uses minimax
            return findBestMove(board);
        }

        function findBestMove(board) {
            let bestScore = -Infinity;
            let move = -1;
            for (let i = 0; i < board.length; i++) {
                if (board[i] === '') {
                    board[i] = 'O'; // AI is 'O'
                    let score = minimax(board, 0, false);
                    board[i] = '';
                    if (score > bestScore) {
                        bestScore = score;
                        move = i;
                    }
                }
            }
            return move;
        }

        function minimax(board, depth, isMaximizing) {
            const scores = { 'X': -10, 'O': 10, 'tie': 0 };
            const result = checkWinner(board);
            if (result) return scores[result.winner];

            let bestScore = isMaximizing ? -Infinity : Infinity;
            for (let i = 0; i < board.length; i++) {
                if (board[i] === '') {
                    board[i] = isMaximizing ? 'O' : 'X';
                    let score = minimax(board, depth + 1, !isMaximizing);
                    board[i] = '';
                    bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);
                }
            }
            return bestScore;
        }

        function checkWinner(board, players) {
            for(let i = 0; i < WIN_PATTERNS.length; i++){
                const [a, b, c] = WIN_PATTERNS[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]){
                    return { winner: board[a], patternIndex: i, players };
                }
            }
            if (!board.includes('')) {
                return { winner: 'tie', patternIndex: null, players };
            }
            return null;
        }
        
        // --- Initialize App ---
        initializeGameUI();
        initializeAuth();
    };
    </script>
</body>
    </html>
